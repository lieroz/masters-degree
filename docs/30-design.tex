\chapter{Конструкторский раздел}
В этом разделе приводится подробное описание разрабатываемого метода, выделяются основные его компоненты, описываются метрики, оценивающие метод. В выводах аналитической части предлагается разработать новый метод распределения оперативной памяти приложений. Новый метод будет включать в себя выделение памяти запрашиваемого размера и ее освобождение.

\section{Структура программного комплекса}
\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=0.5]{images/block-allocation.png}
		\caption{Выделение блока памяти.}
		\label{block-allocation}
	\end{center}
\end{figure}

\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=0.5]{images/block-free.png}
		\caption{Освобождение блока памяти.}
		\label{block-free}
	\end{center}
\end{figure}

Аллокатору передается размер памяти, которую необходимо выделить, в байтах. Далее, в зависимости от того, к какому классу относится размер, есть три варианта выделения памяти:
\begin{itemize}
	\item малые объекты, это объекты размер кототрых менее либо равен 2048-и байтам, они выделяются через специализированный аллокатор для малых объектов;
	\item большие объекты, это объекты размер которых менее либо равен 1МБ по умолчанию, (ограничение может быть изменено, но не должно превышать 268431360 байт) они выделяются через аллокатор для больших объектов;
	\item огромные объекты, класс объектов, размер которых более чем ограничение для больших объектов, такие объекты выделяются сразу через систменый вызов \textbf{mmap}.
\end{itemize}

Результатом запроса в распределитеть памяти является адрес, выровненный по размеру страницы и содержащий в себе всю необходимую информацию для освобождения объекта. После освобождения, память кэшируется в случае для малых и больших запросов. Память под огромные объекты, при освобождениии, сразу возвращается ОС.

\subsection{Основная идея}
Метод основан на использовании старших бит виртуального адреса. На рисунке \ref{64bit-memory-addressing} показана диаграмма перевода виртульного адреса в физический в 64-ъ битной системе.

\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=0.6]{images/64bit-memory-addressing.png}
		\caption{Адресация памяти в 64-х битном режиме.}
		\label{64bit-memory-addressing}
	\end{center}
\end{figure}

Как видно из рисунка \ref{64bit-memory-addressing}, для адресации используются только первые 48 бит из 64-х, остальные 16 бит разграничивают виртуального адресное пространство на зоны нижних и верхних адресов. Биты 63-48 разграничивают знак, если 47-й выставлен в 0, то все верхние 16 тоже выставлены в 0 и такие адреса относятся к нижней половине, если 47-й бит выставлен в 1, то биты 63-48 тоже равны 1 и такие адреса относятся к верхней половине виртульных адресов.

\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=0.6]{images/48bit-half-spaces.png}
		\caption{48-и битная адресация.}
		\label{48bit-half-spaces}
	\end{center}
\end{figure}

Данная реализация распределителся памяти использует верхние 16 бит виртуального 64-х битного адреса для хранения информации о типе (большой/малый) и размерном классе объекта. При запросе на выделение памяти, в вернувшийся адрес записывается информация о классе объекта, за это отвечают биты 62-48. В самый старший бит записывается тип объекта малый/большой.

\subsection{Аллокатор для малых объектов}
Все запросы на выделение памяти размером менее или равным 2048 байт обслуживаются аллокатором для малых объектов. Для каждого потока создается свой такой аллокатор, при завершении работы потока вся память высвобождается ОС. Объекты должны иметь размер кратный степени 2-и начиная с размера в 8 байт и заканчивая размером 2048 байт. Если на вход приходит размер, который не кратен степени 2-ки, то он приводится к ближаешему больгему размеру кратному степени 2-и.

В случае малых объектов, возвращаемому адресу может быть выставлен только один из 15-и старших бит, чтобы можно было точно определить размер объекта при освобождении памяти. Самый старший бит выставляется в 1, чтобы можно было точно определить тип объекта.

\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=0.6]{images/small-allocator-design.png}
		\caption{Общий вид аллокатора для малых объектов.}
		\label{small-allocator-design}
	\end{center}
\end{figure}

Реализация аллокатора включает в себя метаданные и указатели на выделенные страницы памяти, где и находятся все объекты. При запросе на выделение, алокатор инициализирует метаданные, размер метаданных в байтах равен одной странице и память выделяется через \textbf{mmap}. Так как в 64-й системе размер указателя равен 8-и байтам, то метаданные могут содержать 512 указателей на страницы с объектами (размер каждой страницы равен 4 КБ, тоесть системному размеру страницы). Когда польщователь запрашивает память, то есть несколько вариантов исполнения запроса:
\begin{itemize}
	\item аллокатор пустой или не был инициализирован, в таком случае будет выделена отдельная страница под класс объектов и польщователю вернется указатель на эту страницу, в метаданные запишется адрес страницы и указатель на свободный элемент сместится на адрес страницы + размерный класс объекта;
	\item аллокатор уже имеет выделенные страницы памяти, в таком случае он попытается выделить память под текузему указателю на свободную память, если тот выходит за пределы доступной памяти, то происходит поиск свободного элемента в той же странице памяти, (это необходимо для того, чтобы не подгружать новые страницы памяти, потому что физический адрес уже был получен и закэширован в буффере ассоциативной трансляции) если же в странице нет свободной памяти, то будет проихведен поиск по всем страницам и будет возвращена первая найденая область памяти и указатель на свободную память выставлен в адрес текущей старницы + размер объекта, но если свободных объектов не оказалось и есть место в метаданных для выделения новой страницы, то выделяется новая страница и возвращается ее адрес, иначе, аллокатор не сможет удовлетворить запрос;
	\item аллокатор переполнен, это означает что используется память под все 512 страниц и все объекты заняты, большей памятью аллокатор управлять не может и программа завершится.
\end{itemize}

\begin{lstlisting}
static auto createSmallObjectsRegistries()
{
	std::array<SmallObjectsRegistry, 9> registries;
	for (uint64_t index{0}, size{smallObjectsSizeStart}; size <= smallObjectsSizeLimit; ++index, size <<= 1)
	{
		registries[index] = SmallObjectsRegistry{size};
	}
	return registries;
}
	
static SmallObjectsRegistry &getSmallObjectsRegistry(size_t size)
{
	thread_local auto registries = createSmallObjectsRegistries();
	uint64_t index{0};
	for (; size > smallObjectsSizeStart; size >>= 1, ++index)
		;
	return registries[index];
}

void *malloc(size_t size)
{
    void *ptr{nullptr};
	if (size <= smallObjectsSizeLimit)
	{
		size = roundUpToNextPowerOf2(size);
		auto &registry = getSmallObjectsRegistry(size);
		assert(registry.pop(ptr));
	
		uint64_t controlBits = (size << highestVirtualSpaceBit) | smallObjectMask;
		ptr = reinterpret_cast<void *>(reinterpret_cast<uint64_t>(ptr) | controlBits);
	}
	...
	return ptr;
}
\end{lstlisting}

\subsection{Аллокатор для больших объектов}

\subsection{Аллокатор для огромных объектов}